[
["index.html", "Computational Tools for Reproducible Science Overview 0.1 Software Requirements and Installation Instructions", " Computational Tools for Reproducible Science Simona Picardi 2020-11-03 Overview This digital book contains the material for the Graduate Special Topics course WILD 6900: Computational Tools for Reproducible Science. The aim of the course is to provide students with practical skills to manage and process their data throughout their life cycle, from the moment they are entered into a computer to the moment they are used in a publication, document, presentation, etc. The content is organized in the following Chapters: Chapter 1, Project Organization Chapter 2, Version Control with Git Chapter 3, Collaborative Science with GitHub Chapter 4, Best Practices in the Use of Spreadsheets Chapter 5, Relational Databases Chapter 6, Basics of SQL Language Chapter 7, Linking Databases and R with RSQLite Chapter 8, Dynamic Documents with RMarkdown Chapter 9, Automatically Generated Websites with GitHub Pages Chapter 10, Introduction to R Chapter 11, Troubleshooting in R Chapter 12, Working Environments in R Chapter 13, Data Wrangling with tidyverse Chapter 14, Data Visualization with ggplot2 Chapter 15, Introduction to Geospatial Data in R Chapter 16, Problem Decomposition 0.1 Software Requirements and Installation Instructions Required software is listed below along with installation instructions for different operating systems. 0.1.1 Git Git is a distributed version control system. It is free and open source. To install Git, follow instructions for your operating system below: 0.1.1.1 Windows Download from the Git website: go to https://git-scm.com/download/win and the download will start automatically. 0.1.1.2 Mac OS On Mavericks (10.9) or above, when you try to run a Git command from the Terminal for the first time, the installation will start automatically if you don’t already have Git installed. Type the following in the terminal: $ git --version And follow the instructions on the installation wizard. :-) 0.1.1.3 Linux In the command line: $ sudo apt install git-all 0.1.2 Spreadsheet Editor Most people will already have Excel installed on their computer. However, any spreadsheet editor will work for the purpose of this course. If you don’t have access to an Office License, LibreOffice or OpenOffice are free, perfectly viable alternatives to Excel. Download the installer for your operating system: LibreOffice: https://www.libreoffice.org/download/download/ OpenOffice: https://www.openoffice.org/download/ 0.1.3 SQLite SQLite is a lightweight relational database management system. To install it, follow these steps: Go to https://www.sqlite.org/download.html and find your operating system in the list. You are looking for a category called “Precompiled Binaries”. For example, if you are on Windows, look for “Precompiled Binaries for Windows”. From this list, chose the file whose name starts with “sqlite-tools”. The description will read something like, “A bundle of command-line tools for managing SQLite database files, including the command-line shell program, the sqldiff.exe program, and the sqlite3_analyzer.exe program” In your file explorer, create a new folder called “sqlite” (e.g., on Windows, C:) Extract the .zip file you downloaded into this new folder. Download SQLiteStudio (this is a GUI, or Graphical User Interface, that we are going to use to run our SQL commands) here: https://github.com/pawelsalawa/sqlitestudio/releases. Download the file whose name starts with “Install” and choose the .exe extension if you’re working on Windows, .dmg if you’re on Mac OS, and the one without extension if you’re on Linux. If these instructions weren’t clear, you can find more details (with screenshots) at this link: https://www.sqlitetutorial.net/download-install-sqlite/ 0.1.4 R R is a free software environment for statistical computing and graphics. Note that installing or updating R is a separate, independent process from installing or updating RStudio! If you already have R installed, make sure you have the latest available version. Follow installation or update instructions for your operating system below. 0.1.4.1 Windows Download the latest version of R at https://cran.r-project.org/bin/windows/base/ 0.1.4.2 Mac OS Download the latest version of R at https://cran.r-project.org/bin/macosx/ 0.1.4.3 Linux These instructions are for Ubuntu 18.04. If you are running a different version of Debian/Ubuntu, there are some small adjustments to make (see below). In the command line, add the GPG Key: $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 Add the R repository (here is where you have to replace the appropriate release name if you’re working with a different version of Ubuntu; you can find the complete list here: https://cloud.r-project.org/bin/linux/ubuntu/): sudo add-apt-repository &#39;deb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/&#39; Update package lists: $ sudo apt update Install R: $ sudo apt install r-base 0.1.5 RStudio RStudio is a free Integrated Development Environment (IDE) for R. Note that installing or updating RStudio is a separate, independent process from installing or updating R! If you already have RStudio installed, make sure you have the latest available version. Otherwise, go ahead and download it from here: https://rstudio.com/products/rstudio/download/#download (choose the appropriate version for your operating system.) 0.1.6 Required R Packages Throughout the course, we will be using the following R packages: RSQLite, rmarkdown, bookdown, renv, tidyverse, lubridate, raster, and sf. All these packages are on CRAN and can be installed (along with their dependencies) by running the following code in R: install.packages(c(&quot;RSQLite&quot;, &quot;rmarkdown&quot;, &quot;bookdown&quot;, &quot;renv&quot;, &quot;tidyverse&quot;, &quot;lubridate&quot;, &quot;raster&quot;, &quot;sf&quot;), dependencies = TRUE) "],
["project-organization.html", "Chapter 1 Project Organization 1.1 Directory structure 1.2 Golden rules 1.3 Be flexible 1.4 Documentation 1.5 Naming files 1.6 RStudio Projects 1.7 Relative and absolute paths", " Chapter 1 Project Organization 1.1 Directory structure When starting a new project, it is worthwhile to spend some time thinking about how to best organize its content. This means asking questions such as: What are my project inputs? What types of outputs do I expect to come out of this project? How does this project relate to other projects I am working on? Answering these questions can help us decide on a directory structure to house our project files. For example, say that we are working on a research project that entails data cleaning, analysis, and writing of a manuscript. One way to go about it is to have a root project directory that contains subfolders for data, analysis code, results, and the manuscript file/s. We can call this a “project-based directory layout.” Alternatively, if we have multiple projects underway, we can split our files by activity rather than by projects and have a “data” folder, an “analyses” folder, a “manuscripts” folder, etc., all with a subfolder for each project. We can call this an “activity-based directory layout.” Project-based directory organization. Activity-based directory organization. How you define a project is largely up to you. It could be all the work you do on a given dataset, or all the work you do for a thesis or dissertation, or each manuscript could be its own project even if it uses the same dataset as a different project. With so many options, how do we choose? Ultimately, the way you structure your project directories will have a big impact on the efficiency and reproducibility of your work, so there are some criteria to keep in mind. 1.1.1 Overlap The first thing to consider is the overlap in data and code files between a project and other past/current projects. If two projects don’t share any data, it’s probably best to manage them separately. If two projects share a large amount of data, it might make more sense to manage them together as one. If you are writing functions to use across several different projects, they should probably be in their own project. 1.1.2 Minimizing duplication The reason why it’s important to account for overlap is because you want to minimize duplication as much as you can. Duplication of both data and code files is dangerous because it’s easy to lose track of modifications you have made to a file saved in one place but not in the other place. As you keep making changes, the two files will have the same name but different content, which generates confusion. Duplication is also inefficient because it occupies precious space on your computer. 1.1.3 Self-containedness A fundamental quality of reproducible projects is that they are self-contained, meaning that ideally you could zip up the entire project directory and send it to a friend and they should be able to run your code and reproduce your results without changing anything. This means everything the project needs to work, from A to Z – data, functions, code – is contained in its root directory. 1.1.4 Tradeoffs The self-containedness criterion is sometimes in contradiction with minimizing duplication: if two projects share one or more data files, you can either violate the duplication criterion by making sure each project contains all the necessary data for the sake of self-containedness; or you can choose to sacrifice self-containedness to avoid file duplication and save space on your computer. The answer will depend on whether you anticipate the project to be widely shared or mostly for your personal use, how large the shared data files are, etc. The bottom line is that there is no one-size-fits-all solution for project organization. Most importantly, the structure you choose needs to be functional for your needs. Putting thought into it is a great place to start. 1.2 Golden rules Whichever directory structure you choose for a project, there are some universal rules to keep in mind for how to organize files within it. First and foremost, raw data should never be changed. Save it into a “data” folder and treat it as immutable. You can even set it as read-only to make sure there is no room for accidents. The processed, clean version of your data will go into a dedicated “processed_data” folder. Anything that can be generated from code goes into its own folder. This includes basically everything but the raw data and the code itself. You can have an “output” folder, or separate folders for output files and figures (e.g., “output” and “figures”.) If there are text documents, put them in their own folder (e.g., “docs”) Code also has its own folder. If you write a lot of functions, it can be helpful to have a “funs” folder to store those and a “src” (for ‘source’) folder to save processing/analysis code. If processing/analysis scripts are meant to be used in a certain order, you can number them (more on this in a minute.) Sometimes the pipeline is not linear but branched, so numbering may not always make sense. Function scripts should not be numbered. Modularize your code: instead of having a giant script to run your entire analysis from data cleaning to final figures, break up your workflow into several short, single-purpose scripts with well-defined inputs and outputs. 1.3 Be flexible It can be challenging to anticipate the structure of a project that is just about to start (especially the first time you start thinking through optimal directory structures.) It helps to be flexible and allow some room for adjustments. For example, you can start with a basic directory structure where you have a “data” folder, a “code” folder, and an “output” folder, and then you may decide to split the “code” folder into “src” and “funs”, or to further split the “output” folder into “output” and “figures”, etc. Sometimes these changes can break your code and become frustrating, but these problems are easy to fix. Similarly, it can be challenging to have the long-term vision to know where it’s best to break a script and start a new one. It’s easy to tunnel vision into an analysis and keep adding lines and lines of code without thinking about break points that make sense. One good way to deal with this is to reserve some time at the end of your coding session to look at your script and notice if there are any intermediate products that you can save and use as input of the next step of the workflow. Then you can make the necessary adjustments in terms of code compartmentalization, paths to input and output files, etc. In the words of Wilson et al. (2017, see references below), “consistency and predictability are more important than hairsplitting” when organizing the directory structure for your projects. Besides a few universal rules, designing the optimal structure often requires consideration of project specifics. Ultimately, the goal is to improve efficiency – by allowing you to find your files easily, only run the minimal amount of code you need for a task, making it easy for collaborators and future you to wrap your head around the project content – and reproducibility. 1.4 Documentation One very important aspect of reproducibility is good documentation. Each of your projects should always be accompanied by a README file. The README should contain all the information an outsider would need to understand what the project is all about, what are the inputs and outputs, where to find files within the project directory, etc. The README is simply a text file, there’s nothing special to it – you can just create it in your Notepad or other text editor. Writing down everything about a project in a README can be tedious, but it pays off ten-fold. It’s good to get in the habit of starting a project by creating a README file right after the directory structure is created. Record who the author/s is/are, the date the project was started, and a description of what the project is for. Then, any time a new file is added, specify what it is and where you got it from. For example, “File X.csv was sent by Mary White in an email on 2/1/2019 to my.address @ gmail.com”, etc. Be meticulous: what seems obvious today can become a puzzle to solve in a few months. 1.5 Naming files There is a science to choosing good file names, too. Here is a list of file names that are not good, for a variety of different reasons: data.csv data_cleaned_03-22-2012.csv analysis code.R Green Frogs Manuscript_Final_edits.docx final.docx Why are those names bad, and what makes a good file name? Good file names are machine-readable, human-readable, and work well with default ordering. Let’s break these three criteria down one by one. 1.5.1 Machine-readable file names What makes a file name machine readable? First, machine readable files contain no spaces, no punctuation, and no special characters. They are case-consistent, which means that you always stick to the same case pattern, whether that be full lowercase, camel case (ThisIsWhatIMeanByCamelCase), or whatever else. Finally, good file names make deliberate use of text delimiters. Wise use of delimiters makes it easy to look for patterns when you are searching for a specific file. Usually, it’s recommended that you use an underscore (_) to delimit metadata units and a dash (-) to delimit words within a metadata unit. For example, here is a good, machine-readable file name: 2018-04-26_reproducible-science_slides_lesson-01.pptx 1.5.2 Human-readable file names The example file name above is not only machine-readable, it’s also human-readable. This means that a human can read the file name and have a pretty good idea of what’s in that file. Good file names are informative! You shouldn’t be afraid to use long names if that’s what it takes to make them descriptive. 1.5.3 File names that work well with default ordering If you sort your files by name in a folder, you want them to be ordered in a way that makes sense. Whether you sort your files by date or by a sequential number, the number always goes first. For dates, use the YMD format, or your files created in April of 1984 and 2020 will be closer than the ones created in March and April 2020. If you are using sequential numbering, add a sensible amount of zeros in front based on how many files of that category you expect to have in the future. If you expect to have more than 10 but not more than 99 files, you can add a single leading zero (e.g., “data_analysis_01.R” instead of “data_analysis_1.R”), whereas if you expect to have between 100 and 999 you can add two (e.g., “Photo_001.jpeg” instead of “Photo_1.jpeg” or “Photo_01.jpeg”.) 1.6 RStudio Projects RStudio Projects are a great tool to help you stay organized. The concept behind RStudio Projects is that each Project is a self-contained unit where inputs, outputs, and code are all in one place. Sounds familiar? RStudio Projects work seamlessly with the directory organization framework we have been talking about. It’s a good idea to make sure each of the projects (with a lowercase p) you work on has its own associated RStudio Project (with a capital P). How to create a new RStudio Project You may be familiar with the concept of a working directory in R. The working directory is the place where, unless otherwise specified, all of your outputs are saved. All relative paths are also interpreted relative to the working directory (more on relative paths in a minute.) The cool thing about an RStudio Project is that it automatically makes sure that your project directory is set as the working directory. All the clunkiness of having to set, change, or double check which directory you’re working in is forgotten: all you do is open up your Project and then the paths you use to load or save data are already, by default, relative to your project directory. 1.7 Relative and absolute paths Paths define the location of files within the file system. There are two ways to point to a file from within a command prompt such as R. The first is to use what is called an absolute path: this describes the full sequence of folders a file is contained in, starting from the root directory of a computer. When you right click on any file on your computer, you can look up its absolute path in the Properties. This is an example of an absolute path: C:/Users/MJS/Documents/PhD/Planning/schedule_2021.csv Relative paths describe the position of a file with respect to a reference directory. In R, that reference directory is your working directory. When you type a relative path to open a file in R, R appends that path to the path of the working directory to get the full absolute path, which it then uses to open the file. For example, if our working directory was “Documents”, this would be the relative path to reach the same file as above: PhD/Planning/schedule_2021.csv If our working directory was “Planning”, this would be the relative path to the same file: schedule_2021.csv To work across subfolders of our working directory, we can just use relative paths to navigate and locate files. But relative paths also work to navigate across folders that are outside of the working directory, if need be. Using “../” in front of a folder name navigates to the parent of that folder (“parent” means the folder where that is contained.) Let’s consider the following directory structure: Example directory We can navigate to a file into “PhD/Research” from “Planning” like so: ../Research/GreenFrogs/data-cleaning.RProj The “../” means “the parent directory of the working directory”, which is “PhD”. We can also stack these to navigate further up the directory tree: ../../../../DAJ The path above navigates all the way up to “Users” and into a different user’s directory. 1.7.1 Path separators Something to be mindful of is that the separator between folder names in a path is different on different operating systems. On Windows, it is a backslash (“\"), while on Mac/Linux, it is a slash (”/“). However, R uses the Mac/Linux convention, so always use”/\" when typing paths in R. 1.7.2 References Wilson G, Bryan J, Cranston K, Kitzes J, Nederbragt L, Teal TK (2017) Good enough practices in scientific computing. PLoS Comput Biol 13(6): e1005510. https://doi.org/10.1371/journal.pcbi.1005510 https://speakerdeck.com/jennybc/how-to-name-files https://r4ds.had.co.nz/workflow-projects.html "],
["version-control-git.html", "Chapter 2 Version Control with Git", " Chapter 2 Version Control with Git Check Wilson et al. 2017 for some tips on gitignore "],
["github.html", "Chapter 3 Collaborative Science with GitHub", " Chapter 3 Collaborative Science with GitHub "],
["spreadsheets.html", "Chapter 4 Best Practices in the Use of Spreadsheets", " Chapter 4 Best Practices in the Use of Spreadsheets "],
["relational-databases.html", "Chapter 5 Relational Databases", " Chapter 5 Relational Databases "],
["sql.html", "Chapter 6 Basics of SQL Language", " Chapter 6 Basics of SQL Language "],
["rsqlite.html", "Chapter 7 Linking Databases and R with RSQLite", " Chapter 7 Linking Databases and R with RSQLite "],
["rmarkdown.html", "Chapter 8 Dynamic Documents with RMarkdown", " Chapter 8 Dynamic Documents with RMarkdown "],
["github-pages.html", "Chapter 9 Automatically Generated Websites with GitHub Pages 9.1 Bookdown 9.2 Publishing a book with GitHub Pages 9.3 Maintaining the website 9.4 References", " Chapter 9 Automatically Generated Websites with GitHub Pages We have seen how to knit RMarkdown documents into HTML, which is the standard format for web pages. From this to publishing your HTML documents as an actual website is a short step, thanks to GitHub Pages. GitHub Pages lets you turn your GitHub repositories into websites for free. Because it is GitHub, you can manage all the content of your website from RStudio and have it under version control, which means your website is reproducible. Sign us up, amirite?! Here, we are going to see how to create a web book using the R package bookdown and GitHub Pages. 9.1 Bookdown The R package bookdown is built on top of RMarkdown, so it uses the same syntax we have learned so far for writing documents. On top of it, bookdown lets you have multi-page output, cross-referencing between different pages, and it uses the GitBook style to create beautiful, professional-looking digital books. In fact, the book you are reading right now is built with bookdown! 9.1.1 Creating a book Once you have bookdown installed, you can create your first book by opening RStudio and creating a new Project. Select “New Directory”, and then “Book Project using bookdown”. Create a Project in a new directory. Choose “Book Project using bookdown” When you create the Project, bookdown automatically generates all the files you need for your book to function. These include: A .Rproj file, which is your RStudio Project; A README file; An index.Rmd file, which is the first section of your book and by default will be the home page if you publish it as a website; A series of numbered chapters as .Rmd files; Two .yml files, _bookdown.yml and _output.yml, which contain metadata (stuff like the file name of the book, the word used to refer to chapters within the book, etc;) A style.css file, which defines the style and appearance of the book; A preamble.tex file, with more customization options; A book.bib file, which contains the bibliography. Files automatically created by bookdown. In practice, you can ignore most of these files unless you want to customize the appearance and functioning of your book. If all you want to do is edit the content, all you need to care about are the .Rmd files. The other files are necessary for the book to work properly, but you can simply leave them where they are and not worry about them. To knit the book, go to the “Build” tab in RStudio, open the “Build Book” dropdown menu, and choose “bookdown::gitbook” as the output format. This format is compatible with GitHub Pages and will allow us to publish our book as a website. When we do this, bookdown will knit each .Rmd file into HTML format and save them into a new folder called \"_book\". Build bookdown. 9.2 Publishing a book with GitHub Pages To publish the book online using GitHub Pages, we are going to initialize a Git repository in our Project folder, link it up with a GitHub repository, and enable Pages. To enable Pages, we need to tell GitHub where to go find the .html files that compose our book. We have two options: we can put these files into a dedicated branch called “gh-pages”, or we can have them in a folder called “docs” on the main branch. The second option allows for a slightly simpler workflow, so we’ll go with that. 9.2.1 Step 1: Set up compatibility with GitHub Pages By default, bookdown puts the .html files it generates when knitting the book into the \"_book\" folder. Instead, we want these to be in a “docs” folder. We can go ahead and delete the _book folder with all its content (everything in this folder is generated when knitting the files so we can delete it without fear.) Then, we tell bookdown that it should save all the .html files into a folder called “docs” instead of the default \"_book\". We do this by opening the _bookdown.yml file and adding this line to the bottom of it: output_dir: “docs”. We also need to create a file called .nojekyll in the “docs” folder. You can do this by typing touch .nojekyll in your command line (make sure you’re in the Project folder), or you can simply use the notepad to create a new empty file, name it “.nojekyll”, and save it in “docs”. Make sure there’s no file extension (e.g., .txt) at the end of the filename. Notepad will complain and warn you that terrible things will happen if you remove the file extension, but actually they won’t. The reason why we need to create this “.nojekyll” file is because GitHub Pages will assume that your website is built using Jekyll, a static website builder, unless you tell it otherwise. Our website does not use Jekyll, so we tell GitHub that. 9.2.2 Step 2: Set up Git repository It’s time to put our book under version control. To do so, we open a terminal into our Project folder and we initialize a repository: git init After we create our .gitignore file, we can add and commit our files: git add --all git commit -m &quot;First commit&quot; Let’s also rename our main branch: git branch -M main 9.2.3 Step 3: Link Git repository to remote GitHub repository Now, we create an empty GitHub repository to link with our local one. Because we are setting this as the upstream for an existing repository, it must be completely empty, so make sure you are not creating a README file or anything (uncheck all those boxes). Also, make sure you choose the option for a Public repository. GitHub Pages are not available for private repositories. Back in the terminal, we link this newly created remote repository to our local copy (make sure you replace the URL below with the correct one): git remote add origin https://github.com/username/my-repo And we push our files to it: git push -u origin main 9.2.4 Step 4: Enable GitHub Pages The final step is to enable GitHub Pages on our repository. On GitHub, go to the repository Settings. Scroll down to the “GitHub Pages” section. Change the source to the docs folder in the main branch and save: Set up GitHub Pages to work from main, /docs. The site will be published within a few minutes at the address in the green box that just appeared on your screen. 9.3 Maintaining the website Once the website is live, it will be automatically updated any time we push updates to the .html files in the docs folder. Remember that modifying the .Rmd files is not enough for the website to update: we also need to knit the book so that bookdown will update the .html files. This is also a great reminder that you can play around with edits without them showing up on the website if you’re not ready to broadcast them: until you knit the book and push to the remote, the website won’t be updated. 9.4 References https://bookdown.org/yihui/bookdown/ "],
["intro-to-r.html", "Chapter 10 Introduction to R", " Chapter 10 Introduction to R "],
["troubleshooting.html", "Chapter 11 Troubleshooting in R", " Chapter 11 Troubleshooting in R "],
["renv.html", "Chapter 12 Working Environments in R", " Chapter 12 Working Environments in R "],
["tidyverse.html", "Chapter 13 Data Wrangling with tidyverse", " Chapter 13 Data Wrangling with tidyverse "],
["ggplot2.html", "Chapter 14 Data Visualization with ggplot2", " Chapter 14 Data Visualization with ggplot2 "],
["geospatial.html", "Chapter 15 Introduction to Geospatial Data in R", " Chapter 15 Introduction to Geospatial Data in R "],
["problem-decomposition.html", "Chapter 16 Problem Decomposition", " Chapter 16 Problem Decomposition "]
]
